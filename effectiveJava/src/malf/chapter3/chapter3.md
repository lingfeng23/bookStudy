对于所有对象都通用的方法

#####在改写 equals 的时候请遵守通用约定
1、一个类的每个示例本质上都是唯一的。

2、不关心一个类是否提供了“逻辑相等”的测试功能。

3、超类已经改写了 equals，从超类继承过来的行为对于子类也是合适的。

4、一个类是私有的，或者是包级私有的，并且可以确定它的 equals 方法永远也不会被调用。

* 自反性。对于任意的引用值 x，x.equals(x) 一定为 true。
* 对称性。对于任意的引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 也一定返回 true.
* 传递性。对于任意的引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 也返回 true，那么 x.equals(z) 也一定返回 true。
* 一致性。对于任意的引用值 x 和 y，如果用于 equals 比较的对象信息没有被修改的话，那么多次调用 x.equals(y) 要么一致地返回 true，要么一致地返回 false。
* 非空性。对于任意的非空引用值 x，x.equals(null) 一定返回 false。
#####实现高质量 equals 方法的注意事项
1、使用 == 操作符检查“实参是否为指向对象的一个引用”。

2、使用 instanceof 操作符检查“实参是否为正确的类型”。

3、把实参转换到正确的类型。

4、对于该类中每一个“关键”域，检查实参中的域与当前对象中对应的域值是否匹配。

* 当你改写 equals 的时候，总是要改写 hashCode。
* 不要企图让 equals 方法过于聪明。
* 不要使 equals 方法依赖于不可靠的资源。
* 不要将 equals 声明中的 Object 对象替换为其他的类型。
#####改写 equals 时总是要改写 hashCode。
#####总是要改写 toString
#####谨慎地改写 clone